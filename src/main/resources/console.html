<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>控制台输出</title>
    <link rel="stylesheet" href="css/all.min.css">
    <style>
        :root { --primary-color:#4a6cf7; --secondary-color:#6c757d; --light-color:#f8f9fa; --dark-color:#343a40; }
        body { font-family:'Inter','Segoe UI',Roboto,sans-serif; background:#f5f7fa; color:#333; margin:0; }
        .header { position:sticky; top:0; z-index:10; background:#fff; border-bottom:1px solid #eee; padding:16px; display:flex; align-items:center; justify-content:space-between; }
        .title { display:flex; align-items:center; gap:10px; font-size:20px; font-weight:700; color:var(--primary-color); }
        .actions { display:flex; gap:10px; }
        .btn { border:none; padding:8px 14px; border-radius:6px; cursor:pointer; display:inline-flex; align-items:center; gap:6px; font-size:14px; }
        .btn-primary { background:var(--primary-color); color:#fff; }
        .btn-secondary { background:var(--secondary-color); color:#fff; }
        .content { padding:16px; }
        .panel { background:#fff; border:1px solid #eee; box-shadow:0 2px 10px rgba(0,0,0,0.05); }
        .toolbar { display:flex; align-items:center; gap:12px; padding:12px; border-bottom:1px solid #eee; }
        .log { height:70vh; overflow:auto; padding:16px; font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; background:#0f172a; color:#e5e7eb; }
        .log pre { margin:0; white-space:pre-wrap; word-break:break-word; }
        .status { font-size:12px; color:#666; margin-left:auto; }
        .input { padding:6px 10px; border:1px solid #ddd; }
    </style>
</head>
<body>
    <header class="header">
        <div class="title"><i class="fas fa-terminal"></i><span>控制台输出</span></div>
        <div class="actions">
            <button class="btn btn-secondary" onclick="window.location.href='/'"><i class="fas fa-home"></i> 返回首页</button>
        </div>
    </header>
    <main class="content">
        <div class="panel">
            <div class="toolbar">
                <button class="btn btn-primary" id="refreshBtn"><i class="fas fa-sync-alt"></i> 刷新</button>
                <label style="display:inline-flex; align-items:center; gap:6px;">
                    <input type="checkbox" id="autoRefresh"> 自动刷新
                </label>
                <label style="display:inline-flex; align-items:center; gap:6px;">
                    间隔(ms)
                    <input class="input" type="number" id="intervalInput" value="2000" min="500" style="width:90px;">
                </label>
                <div class="status" id="statusText"></div>
            </div>
            <div class="log" id="logContainer"><pre id="consoleContent"></pre></div>
        </div>
    </main>
    <script>
        const logEl = document.getElementById('consoleContent');
        const container = document.getElementById('logContainer');
        const statusText = document.getElementById('statusText');
        const refreshBtn = document.getElementById('refreshBtn');
        const autoRefresh = document.getElementById('autoRefresh');
        const intervalInput = document.getElementById('intervalInput');
        let timer = null;
        let ws = null;
        let wsConnected = false;
        const decoder = new TextDecoder('utf-8');
        let pending = [];
        let flushScheduled = false;
        function nearBottom() { return Math.abs(container.scrollHeight - container.scrollTop - container.clientHeight) < 10; }
        function scrollBottom() { container.scrollTop = container.scrollHeight; }

        async function fetchConsole() {
            const t0 = Date.now();
            statusText.textContent = '加载中...';
            try {
                const res = await fetch('/api/sys/console');
                const text = await res.text();
                const atBottom = Math.abs(container.scrollHeight - container.scrollTop - container.clientHeight) < 10;
                logEl.textContent = text;
                if (atBottom) container.scrollTop = container.scrollHeight;
                statusText.textContent = `已更新 · ${new Date().toLocaleTimeString()} · 大小 ${text.length.toLocaleString()} 字符 · 用时 ${(Date.now()-t0)}ms`;
            } catch (e) {
                statusText.textContent = '加载失败';
            }
        }

        function appendLine(line) {
            const clean = (line || '').replace(/\r/g, '');
            const withNl = clean.endsWith('\n') ? clean : clean + '\n';
            pending.push(withNl);
            if (!flushScheduled) {
                flushScheduled = true;
                requestAnimationFrame(() => {
                    flushScheduled = false;
                    const atBottom = nearBottom();
                    const chunk = pending.join('');
                    pending = [];
                    logEl.textContent += chunk;
                    if (atBottom) scrollBottom();
                });
            }
        }

        function connectWebSocket() {
            try {
                const url = (location.protocol === 'https:' ? 'wss://' : 'ws://') + location.host + '/ws';
                ws = new WebSocket(url);
                ws.onopen = () => {
                    wsConnected = true;
                    statusText.textContent = 'WebSocket已连接';
                    try { ws.send(JSON.stringify({ type: 'connect' })); } catch {}
                    if (autoRefresh.checked) { autoRefresh.checked = false; stopAuto(); }
                };
                ws.onmessage = (ev) => {
                    try {
                        const msg = JSON.parse(ev.data);
                        if (msg && msg.type === 'console') {
                            let text = '';
                            if (typeof msg.line64 === 'string') {
                                const bin = atob(msg.line64);
                                const bytes = new Uint8Array(bin.length);
                                for (let i = 0; i < bin.length; i++) bytes[i] = bin.charCodeAt(i);
                                text = decoder.decode(bytes);
                            } else if (typeof msg.line === 'string') {
                                text = msg.line;
                            }
                            if (text) appendLine(text);
                        }
                    } catch {}
                };
                ws.onerror = () => { statusText.textContent = 'WebSocket错误'; };
                ws.onclose = () => { wsConnected = false; statusText.textContent = 'WebSocket已关闭'; };
            } catch {}
        }

        function startAuto() {
            stopAuto();
            const interval = Math.max(500, parseInt(intervalInput.value || '2000', 10));
            timer = setInterval(fetchConsole, interval);
        }
        function stopAuto() { if (timer) { clearInterval(timer); timer = null; } }

        refreshBtn.addEventListener('click', fetchConsole);
        autoRefresh.addEventListener('change', () => { if (autoRefresh.checked) startAuto(); else stopAuto(); });
        intervalInput.addEventListener('change', () => { if (autoRefresh.checked) startAuto(); });

        fetchConsole();
        connectWebSocket();
    </script>
</body>
</html>
